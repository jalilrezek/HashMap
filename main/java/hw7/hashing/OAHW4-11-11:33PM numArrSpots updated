// numOccupiedArraySpots is reset to numElem after a rehashing operation, as appropriate.



package hw7.hashing;

import hw7.Map;
import java.util.Iterator;

public class OpenAddressingHashMap<K, V> implements Map<K, V> {

  private Pair[] table;
  private int numElem; // num elements. The "size" of our HashMap() (which doesn't count tombstones)

  private int numOccupiedArraySpots; // numElem plus num tombstones. This differs from "numElem" only in that
  // it is NOT decremented when we replace an entry with a tombstone.
  // this is TOTAL SIZE

  private int M; // size of array

  private final double LOAD_FACTOR = 0.75;

  private static final Pair<?, ?> TOMBSTONE = new Pair<>(null, null);

  private int primes[] = {5, 11, 23, 47, 97, 197, 397, 797, 1597, 3203, 6421, 12853,
          25717, 51437,102877, 205759, 411527, 823117, 1646237,3292489, 6584983, 13169977};

  private int primesIndex = 0;

  public OpenAddressingHashMap() {
    M = primes[primesIndex];
    this.table = new Pair[M]; // is the size up to me? TA said if you start with more than 5
    this.numOccupiedArraySpots = 0;
    this.numElem = 0; // you lose points. Growing is a big part of the assignment. Starting with large size
  } // reduces growth.

  private int getIndex(K key) {
    int result = Math.abs(key.hashCode()) % M;
    //System.out.println("In getIndex(). Result is: " + result + " M is: " + M);
    return result;
  }

  private void rehashAndGrow() {
    primesIndex++;
    if (primesIndex < primes.length) {
      M = primes[primesIndex];
    } else {
      M *= 2;
    }

    Pair[] tmp = new Pair[M];

    for (int i = 0; i < table.length; i++) {
      if (table[i] != null && !table[i].equals(TOMBSTONE)) {
        K key = (K) (table[i].key);
        int indexInNewArray = getIndex(key);
        while (tmp[indexInNewArray] != null) {
          indexInNewArray = (indexInNewArray + 1) % M;
        }
        tmp[indexInNewArray] = table[i];
      }
    }
    table = tmp;
    numOccupiedArraySpots = numElem;
  }


  @Override
  public void insert(K k, V v) throws IllegalArgumentException {
    if (k == null || has(k)) {
      throw new IllegalArgumentException();
    }
    numElem++;
    numOccupiedArraySpots++;

    if ( (double) numOccupiedArraySpots / M > LOAD_FACTOR ) {
      rehashAndGrow();
    }
    int index = getIndex(k);

    while ( table[index] != null && !(table[index].equals(TOMBSTONE)) ) {
      index = (index + 1) % M;
    }

    table[index] = new Pair<>(k, v);

  }

  @Override
  public V remove(K k) throws IllegalArgumentException {
    if (k == null || !has(k)) {
      throw new IllegalArgumentException();
    }
    int index = getIndex(k);

    while (table[index] != null) {
      if (table[index] != TOMBSTONE && ((K) table[index].key).equals(k)) {
        // found it
        numElem--;
        V removedVal = (V) table[index].value;
        table[index] = TOMBSTONE;
        return removedVal;
      }
      index = (index + 1) % M;
    }

    assert false; // should never reach this point
    return null;
  }

  @Override
  public void put(K k, V v) throws IllegalArgumentException {
    if (k == null || !has(k)) {
      throw new IllegalArgumentException();
    }
    int index = getIndex(k); // element is in there, around this index
    for (int i = 0; i < M; i++) {
      if (table[index] == null || table[index].equals(TOMBSTONE)) { // shouldn't be possible for it to be null
        // continue
      } else if ( ((K) table[index].key).equals(k) ) {
        table[index] = new Pair<>(k, v);
        return;
      }
      index = (index + 1) % M;
    }
  }

  @Override
  public V get(K k) throws IllegalArgumentException {
    if (k == null || !has(k)) {
      throw new IllegalArgumentException();
    }
    int index = getIndex(k);

    for (int i = 0; i < M; i++) {
      if (table[index].equals(TOMBSTONE) || table[index] == null) { // shouldn't be possible for it to be null
        // continue
      } else if ( ((K) table[index].key).equals(k)) {
        return (V) table[index].value;
      }
      index = (index + 1) % M;
    }
    assert false; // should not reach this.
    return null;
  }

  @Override
  public boolean has(K k) {
    if (empty()) {
      return false;
    }
    if (k == null) {
      throw new IllegalArgumentException(); // unchecked
    }

    int index = getIndex(k);

    for (int i = 0; i < M; i++) {
      if (table[index] == null) {
        return false;
      } else if (table[index].equals(TOMBSTONE)) {
        // key is null, so cannot do ".equals(k)". Continue
      } else if ( ((K) table[index].key).equals(k) ) {
        return true;
      }
      index = (index + 1) % M;
    }
    return false;
  }

  @Override
  public int size() {
    // TODO Implement Me!
    return numElem;
  }

// @Override // my addition. Show size of underlying array.
//  public int totalSize() {
//    return M;
//  }



  public boolean empty() {
    return numElem == 0;
  }

  private static class Pair<K,V> {
    K key;
    V value;

    Pair(K k, V v) {
      this.key = k;
      this.value = v;
    }
  }

  @Override
  public Iterator<K> iterator() {
    // TODO Implement Me!
    return null;
  }
}
